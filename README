SPACE PACMAN README
Alice Ren
CIS 120 Final Project
December 2014
=====================

/////////////////////
Game.java
/////////////////////
This is the Main class of the game. It constructs and displays the elements
of the GUI, including the Instructions window and the main game window, using
JFrames and JPanels.

/////////////////////
Instructions.java
/////////////////////
An extension of JPanel that loads an image file containing instructions for
the game.

/////////////////////
GameCharacter.java
/////////////////////
An interface used for most of the other objects in the game, because
they share the following common methods:
+ void move()
+ void draw(Graphics g)
+ int getX()
+ int getY()
+ int getRadius()
These methods are implemented in the individual classes depending on what the
character looks like and what it does.

/////////////////////
GameCourt.java (includes Pacman class)
/////////////////////
This class does the majority of the heavy lifting. It creates instances of
the Wall, Food, Pacman, and Ghost classes and handles the logic for how they
interact.

Significant Methods in GameCourt:
+ GameCourt(JLabel lives, JLabel score): initializes (or calls helper methods
to initialize) the walls, dots ("food"), Pacman, and ghost with the appropriate
settings. Also initializes all the fields of GameCourt as appropriate. Most
importantly, it creates and starts a timer that calls tick() (see next).
+ tick(): responsible for updating all the components in GameCourt and 
maintaining the running game logic. It checks the field variables to see if
the game is over, if Pacman has died and should reset, and finally calls
the update() and move() functions for Pacman and the ghost. It also calls
collide() to run collision detection.
+ collide(): iterates through all of the walls, all of the ghosts, and all of
the foods to check for collision detection for both Pacman and the ghost. It
makes use of each character's bounce() method to prevent the characters from
going through the walls, and updates the states of the ghost and/or Pacman
and/or the score depending on what collided with what (ghost collided with
Pacman vs Pacman collided with food).
+ frighten(): triggered when Pacman eats a special dot ("SuperFood"), it makes
all the ghosts vulnerable to being eaten by Pacman (they turn blue) for a 
certain amount of time.
+ reset(): resets all of the variables and positions of the characters to the
default.
+ gameOver(): stops the timer (because the game is over) and sets the boolean
"playing" to false, triggering the Game Over screen.
+ resetAfterDeath(): different from the rest() method, because we only want to
reset the Pacman and ghost's positions after the Pacman has died, not the
scores or dots.
+ isWithinGameCharacter: a helper function that takes in a GameCharacter and
four points denoting a rectangle, and returns whether or not the GameCharacter
intersects with that rectangle.
+ paintComponent: responsible for drawing all of the components, usually
according to their own specific methods (GameCharacter.draw()), but also
handles the logic for drawing the GameOver screen based on the value of
the "playing" boolean
+ keyPressed, keyReleased: detect whether or not a key was pressed or
released and updates the appropriate boolean associated with that key

Pacman:
Instead of having Pacman in its own class file, I placed it after the GameCourt
class in the GameCourt.java file so that it could have shared access to
GameCourt's arrow key booleans ("left", "right", "up", "down") and adjust
its velocity accordingly. This meant I could avoid having GameCourt handle
Pacman's movement, which would have been confusing and not very logical, not
to mention difficult (because it would then need access to Pacman's x and y
positions, velocities, etc.).
Significant Methods:
+ update(): accesses the arrow key booleans (which are themselves updated in
GameCourt) and updates Pacman's velocity accordingly (adds acceleration in
the direction of the arrow key pressed, up to a certain speed; then applies
friction). Also pulls the rotationAngle in the direction of the key pressed.
+ move(): makes sure Pacman doesn't go beyond the boundaries of the game window,
then adds the velocity to the x- and y-position of Pacman to make him move.
+ bounce(): reverses Pacman's velocity, because this method is called when he
hits something, and (naively) tries to reposition him so that he is no longer
intersecting whatever he collided with.
+ draw(): draws Pacman as an arc, with the start and added angle changing based
on time and rotationAngle.
Cool things:
+ the int "rotationAngle" keeps track of the angle Pacman's mouth should be
pointing in, based on which keys are being pressed. This means that instead of
the normal, boring left/right/up/down orientations, Pacman dynamically turns
to face whatever direction he is being steered in.
+ instead of just having Pacman's mouth switch between existing and not
existing, I added an intermediate phase that changes according to a timer so the
chomping animation is smoother.

/////////////////////
Ghost.java (implements GameCharacter)
/////////////////////
Instead of using the Graphics library's draw methods, the ghost is drawn
using a series of image files: a normal one, and a blue and white one for
when the ghost is in the "frightened" phase.
Additionally, the ghost has two different patterns of movement while in the
maze: SCATTER and CHASE. In the SCATTER phase, the ghost will pick random
directions to move in. In the CHASE phase, the ghost will head towards the
Pacman and try to get as close as possible.
The ghost also has its own timer to keep track of when it is in the frightened
phase, and will flash between the blue and white images towards the end
of the frightened phase.

/////////////////////
Food.java (implements GameCharacter)
/////////////////////
Food does not move, so its move() function simply returns. Its primary field
is the "hide" boolean, which determines whether or not it is shown (i.e.
whether or not Pacman has eaten it). 
Note: I imagine a more elegant implementation would probably have been to
subtract each Food from the foods<Food> ArrayList in GameCourt as Pacman ate it,
but that would have created problems because we were iterating through the list
while subtracting.

/////////////////////
SuperFood.java (extends Food)
/////////////////////
SuperFood extends the Food class and is identical except for its appearance,
which is larger and lighter in color. It is a subclass so that we can use
"instanceof" in the GameCourt class to tell when Pacman has eaten a SuperFood
instead of a regular Food.

/////////////////////
Wall.java
/////////////////////
Wall is essentially a blue rectangle; the collision logic is handled in
GameCourt.

/////////////////////
GhostBoxWall.java, InvisibleGhostBoxWall.java (both extend Wall)
/////////////////////
GhostBoxWall and InvisibleGhostBoxWall were subclassed to avoid issues with
Pacman colliding with the walls of the "ghost box". InvisibleGhostBoxWall's
draw() method draws an invisible box that is the exact size of the ghost box,
to ensure that Pacman cannot enter the ghost box.